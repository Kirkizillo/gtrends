name: Google Trends Monitor

on:
  # Grupos escalonados para evitar colisiones
  # Horarios ajustados 2026-01-29: evitar 12:00 y 16:00 UTC (66% tasa de fallo)
  schedule:
    - cron: '0 0,14 * * *'   # group_1: WW, IN, US, BR (12:00 -> 14:00)
    - cron: '5 4,18 * * *'   # group_2: ID, MX, PH, GB (+5 min offset, 16:00 -> 18:00)
    - cron: '10 8,20 * * *'  # group_3: AU, VN, DE, RU (+10 min offset) - sin cambios

  # Permitir ejecuciÃ³n manual desde GitHub
  workflow_dispatch:
    inputs:
      group:
        description: 'Country group to run (leave empty for all)'
        required: false
        default: ''
        type: choice
        options:
          - ''
          - 'group_1'
          - 'group_2'
          - 'group_3'

# Permisos necesarios para crear issues
permissions:
  contents: read
  issues: write

jobs:
  # Determinar quÃ© grupo ejecutar basado en la hora
  determine-group:
    runs-on: ubuntu-latest
    outputs:
      group: ${{ steps.set-group.outputs.group }}
    steps:
      - name: Determine group from schedule
        id: set-group
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "group=${{ github.event.inputs.group }}" >> $GITHUB_OUTPUT
          else
            # Usar rangos de horas para tolerar retrasos de GitHub Actions (hasta ~2h)
            # Crons: group_1=0,14h, group_2=4,18h, group_3=8,20h
            HOUR=$(date -u +%H)
            if [ "$HOUR" -ge 0 ] && [ "$HOUR" -lt 4 ]; then
              echo "group=group_1" >> $GITHUB_OUTPUT   # 00:00-03:59 UTC (cron 0h)
            elif [ "$HOUR" -ge 4 ] && [ "$HOUR" -lt 8 ]; then
              echo "group=group_2" >> $GITHUB_OUTPUT   # 04:00-07:59 UTC (cron 4h)
            elif [ "$HOUR" -ge 8 ] && [ "$HOUR" -lt 14 ]; then
              echo "group=group_3" >> $GITHUB_OUTPUT   # 08:00-13:59 UTC (cron 8h)
            elif [ "$HOUR" -ge 14 ] && [ "$HOUR" -lt 18 ]; then
              echo "group=group_1" >> $GITHUB_OUTPUT   # 14:00-17:59 UTC (cron 14h)
            elif [ "$HOUR" -ge 18 ] && [ "$HOUR" -lt 20 ]; then
              echo "group=group_2" >> $GITHUB_OUTPUT   # 18:00-19:59 UTC (cron 18h)
            else
              echo "group=group_3" >> $GITHUB_OUTPUT   # 20:00-23:59 UTC (cron 20h)
            fi
          fi

  scrape-and-export:
    needs: determine-group
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Create credentials file
        env:
          GOOGLE_CREDENTIALS: ${{ secrets.GOOGLE_CREDENTIALS }}
        run: |
          echo "$GOOGLE_CREDENTIALS" > credentials.json

      - name: Create .env file
        env:
          GOOGLE_SHEET_ID: ${{ secrets.GOOGLE_SHEET_ID }}
          PROXIES: ${{ secrets.PROXIES }}
        run: |
          echo "GOOGLE_SHEET_ID=$GOOGLE_SHEET_ID" > .env
          echo "GOOGLE_CREDENTIALS_PATH=credentials.json" >> .env
          echo "PROXIES=$PROXIES" >> .env

      - name: Run Google Trends Monitor
        run: |
          GROUP="${{ needs.determine-group.outputs.group }}"
          if [ -n "$GROUP" ]; then
            python main.py --group $GROUP
          else
            python main.py
          fi
        timeout-minutes: 90

      - name: Upload logs as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: logs-${{ github.run_number }}-${{ needs.determine-group.outputs.group || 'all' }}
          path: logs/
          retention-days: 7

      - name: Notify on failure (Slack)
        if: failure() && env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"Google Trends Monitor failed! Group: ${{ needs.determine-group.outputs.group || 'all' }} - Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}" \
            $SLACK_WEBHOOK_URL

      - name: Create issue on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const title = `Scraping failed - ${new Date().toISOString().split('T')[0]}`;
            const body = `## Scraping Failed\n\n- **Group:** ${{ needs.determine-group.outputs.group || 'all' }}\n- **Run:** [View logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n- **Time:** ${new Date().toISOString()}\n\nPlease check the logs for more details.`;

            // Check if similar issue exists in last 24h
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'scraping-failure',
              per_page: 5
            });

            const recentIssue = issues.data.find(i => {
              const created = new Date(i.created_at);
              const now = new Date();
              return (now - created) < 24 * 60 * 60 * 1000;
            });

            if (!recentIssue) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['scraping-failure', 'automated']
              });
            }

      - name: Close resolved issues on success
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'scraping-failure'
            });

            for (const issue of issues.data) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'completed'
              });
              console.log(`Closed issue #${issue.number}: ${issue.title}`);
            }
